<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Syscoin OP_RETURN Block Finder — v6.7 (fixed syntax + pools + live)</title>
  <meta name="description" content="Scan recent Bitcoin blocks for OP_RETURN or coinbase ScriptSig patterns. Shows pool names & logos. Live updates via WebSocket. Syscoin is merge-mined with Bitcoin." />
  <meta name="theme-color" content="#0b0c0f" />
  <style>
    :root{--bg:#0b0c0f;--panel:#101114;--muted:#a1a1aa;--line:#232327;--accent:#22c55e;--accent-2:#16a34a;--text:#fafafa}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    header{position:sticky;top:0;background:rgba(16,17,20,.8);backdrop-filter:blur(8px);border-bottom:1px solid var(--line);z-index:10}
    .wrap{max-width:1120px;margin:0 auto;padding:16px}
    .grid{display:grid;gap:16px}
    @media(min-width:900px){.grid{grid-template-columns:1fr 1fr}}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));border:1px solid var(--line);border-radius:16px;padding:16px}
    .row{display:flex;align-items:center;gap:12px}
    .row.wrap{flex-wrap:wrap}
    .muted{color:var(--muted)}
    input[type="text"],input[type="search"]{width:100%;background:#0b0c0f;border:1px solid var(--line);border-radius:12px;padding:10px 12px;color:#fafafa;outline:none}
    input[type="checkbox"]{width:16px;height:16px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #234;background:rgba(34,197,94,.12);color:#86efac;font-size:12px}
    .item{display:flex;gap:16px;align-items:center;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));border-radius:16px;padding:14px}
    .logo{width:56px;height:56px;border-radius:12px;background:#11131a;display:grid;place-items:center;overflow:hidden}
    .logo img{max-width:48px;max-height:48px}
    a{color:#a7f3d0;text-decoration:underline}
    a:hover{text-decoration:none}
    footer{color:#8b8b92;font-size:12px;margin-top:24px}
    .tests{font-size:12px;color:#a1a1aa}
    .tests .ok{color:#86efac}
    .tests .fail{color:#fca5a5}
    .status{font-size:12px;color:#a1a1aa}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid var(--line);background:#0f1116}
    .pools{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px}
    .poolCard{display:flex;align-items:center;gap:10px;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));border-radius:12px;padding:8px}
    .poolCard .logo{width:36px;height:36px}
    .poolCard .logo img{max-width:30px;max-height:30px}
    .kpi{display:flex;gap:10px;align-items:center}
    .kpi .dot{width:8px;height:8px;border-radius:999px;background:var(--accent)}
    /* Header branding */
    .brand{display:flex;align-items:center;gap:12px}
    .brandTitle{font-size:20px;font-weight:700}
    .brandLogos{display:flex;align-items:center;gap:8px;margin-left:10px}
    .brandLogos img{width:28px;height:28px;border-radius:6px;background:#0f1116;padding:4px;border:1px solid var(--line)}
    .gifCard img{width:100%;height:auto;border-radius:12px;border:1px solid var(--line);display:block}
  </style>
</head>
<body>
  <header>
    <div class="wrap row">
      <div class="brand">
        <div class="brandTitle">Syscoin OP_RETURN Block Finder</div>
        <div class="brandLogos" title="Bitcoin & Syscoin">
          <img src="https://cryptologos.cc/logos/bitcoin-btc-logo.svg?v=029" alt="Bitcoin logo" loading="lazy"/>
          <img src="https://cryptologos.cc/logos/syscoin-sys-logo.svg?v=029" alt="Syscoin logo" loading="lazy"/>
        </div>
      </div>
      <div class="row" style="margin-left:auto;gap:16px">
        <div class="muted kpi"><span class="dot"></span>API: <span id="apiBase" class="badge">–</span></div>
        <div class="muted">Syscoin Hashrate: <span id="hashrate">–</span></div>
      </div>
    </div>
  </header>

  <main class="wrap" style="padding-block:20px">
    <section class="grid" style="margin-bottom:16px">
      <div class="card">
        <h3 style="margin:0 0 8px 0">Pattern</h3>
        <p class="muted" style="margin:0 0 10px 0">Matches anywhere in a block (any tx OP_RETURN or coinbase scriptSig). “?” = any 1 byte. Defaults to <span class="mono">sys</span>.</p>
        <div class="row wrap" style="margin-bottom:10px">
          <label class="row muted" style="gap:6px"><input type="checkbox" id="useAscii" checked/> Use ASCII (auto→HEX)</label>
          <label class="row muted" style="gap:6px"><input type="checkbox" id="useWildcard" /> Treat ? as wildcard (1 byte)</label>
        </div>
        <div id="asciiBox" style="display:block;margin-bottom:8px">
          <input id="asciiInput" type="text" placeholder="Type ASCII here" />
          <div class="muted" style="font-size:12px;margin-top:6px">HEX: <span class="mono" id="asciiAsHex"></span></div>
        </div>
        <div><input id="hexInput" type="search" placeholder="hex bytes" /></div>
        <div class="status" style="margin-top:8px">Auto-scanning: last <b>50</b> matching blocks are shown and new blocks append automatically.</div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 8px 0">Activity</h3>
        <div class="row wrap" style="margin-bottom:8px">
          <div class="muted">Blocks scanned: <span id="blocksChecked">0</span></div>
          <div class="muted">Txs scanned: <span id="txChecked">0</span></div>
          <div class="muted">Matches: <span id="matches">0</span></div>
          <div class="muted" style="margin-left:auto">Last update: <span id="lastUpdate">–</span></div>
        </div>
        <div id="error" style="margin-top:6px;color:#fca5a5;display:none"></div>
      </div>
    </section>

    <section class="card" id="poolsCard">
      <div class="row wrap" style="justify-content:space-between">
        <h3 style="margin:0">Pools (this session)</h3>
        <div class="muted" style="font-size:12px">Detected via mempool extras / coinbase tags / payout addresses</div>
      </div>
      <div id="poolsBox" class="pools" style="margin-top:10px"></div>
    </section>

    <!-- Fun / GIF section -->
    <section class="card gifCard" aria-label="Satoshi shrug gif">
      <div class="row wrap" style="justify-content:space-between">
        <h3 style="margin:0">Meanwhile…</h3>
        <div class="muted" style="font-size:12px">(Put <code>satoshi-bitcoin.gif</code> next to <code>index.html</code> or in <code>/public</code> on Vercel)</div>
      </div>
      <div style="margin-top:10px">
        <img src="./satoshi-bitcoin.gif" alt="Satoshi shrugging gif" loading="lazy"/>
      </div>
    </section>

    <section id="list" class="grid" style="grid-template-columns:1fr;gap:10px;margin-top:16px"></section>

    <section class="card tests" id="testsBox" style="display:none">
      <div style="font-weight:600;margin-bottom:8px">Self-tests</div>
      <ul id="tests"></ul>
    </section>

    <footer>
      Data sources: Esplora APIs (mempool.space, blockstream.info); mining-pool mappings (GitHub) for pool names & logos; Chainz for Syscoin hashrate. WebSocket for live blocks.
    </footer>
  </main>

  <script>
    // --- Endpoints ---
    const ESPLORA_BASES = ["https://mempool.space/api","https://blockstream.info/api"];
    const MEMPOOL_API = "https://mempool.space/api";
    const WS_URL = "wss://mempool.space/api/v1/ws"; // subscribe to new blocks
    const POOLS_JSON_URL = "https://raw.githubusercontent.com/mempool/mining-pools/master/pools-v2.json";
    const POOL_LOGO_BASE = "https://raw.githubusercontent.com/mempool/mining-pool-logos/master";
    const SYSCOIN_HASHRATE_URL = "https://chainz.cryptoid.info/sys/api.dws?q=nethashps";

    // --- Elements ---
    const $ = (id) => document.getElementById(id);
    const elApiBase=$("apiBase"), elHashrate=$("hashrate"), elError=$("error"), elList=$("list");
    const elUseAscii=$("useAscii"), elUseWildcard=$("useWildcard"), elAsciiBox=$("asciiBox");
    const elAsciiInput=$("asciiInput"), elAsciiAsHex=$("asciiAsHex"), elHexInput=$("hexInput");
    const elTestsBox=$("testsBox"), elTests=$("tests");
    const elBlocksChecked=$("blocksChecked"), elTxChecked=$("txChecked"), elMatches=$("matches"), elLastUpdate=$("lastUpdate");
    const elPoolsBox=$("poolsBox");

    const DEFAULT_ASCII = "sys";

    // --- Utils ---
    const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
    const nowStr=()=>new Date().toLocaleTimeString();
    function asciiToHex(str){ let s=''; for(let i=0;i<str.length;i++) s+=str.charCodeAt(i).toString(16).padStart(2,'0'); return s; }
    function hexToAscii(hex){ try{ let c=String(hex||'').replace(/[^0-9a-f]/gi,''); let o=''; for(let i=0;i<c.length;i+=2){ let b=parseInt(c.substring(i,i+2),16); if(Number.isNaN(b)) continue; o+= (b>=0x20&&b<=0x7e)?String.fromCharCode(b):'.'; } return o; }catch(e){ return ''; } }
    const shortHash=(h,n=10)=>!h?'':(h.length<=2*n?h:(h.slice(0,n)+'…'+h.slice(-n)));
    function formatHps(hps){ if(hps==null||!Number.isFinite(hps)) return '–'; const u=[[1,' H/s'],[1e3,' kH/s'],[1e6,' MH/s'],[1e9,' GH/s'],[1e12,' TH/s'],[1e15,' PH/s'],[1e18,' EH/s']]; let x=hps,i=0; while(i<u.length-1&&x>=1000){x/=1000;i++;} return x.toFixed(2)+u[i][1]; }
    const bust=(u)=>u+(u.includes('?')?'&':'?')+'t='+Date.now(); // cache-buster to avoid CDN caches

    // --- Fetch helpers ---
    async function fetchJSON(url, opts){
      const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(), (opts&&opts.timeout)||15000);
      try{ const res=await fetch(url,{...opts,signal:ctrl.signal,cache:(opts&&opts.cache)||'no-store'}); if(!res.ok) throw new Error(res.status+" "+res.statusText); return await res.json(); } finally{ clearTimeout(t); }
    }
    async function fetchTEXT(url, opts){
      const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(), (opts&&opts.timeout)||15000);
      try{ const res=await fetch(url,{...opts,signal:ctrl.signal,cache:(opts&&opts.cache)||'no-store'}); if(!res.ok) throw new Error(res.status+" "+res.statusText); return await res.text(); } finally{ clearTimeout(t); }
    }

    // --- Esplora selection ---
    let BTC_API_BASE=null;
    async function pickEsploraBase(){
      for (const base of ESPLORA_BASES){
        try{ await fetchJSON(bust(base+"/blocks"), { timeout:8000 }); BTC_API_BASE=base; elApiBase.textContent=new URL(base).host; return base; }catch(e){}
      }
      throw new Error('No Esplora API reachable');
    }
    const api=(path)=>{ if(!BTC_API_BASE) throw new Error('Esplora base not set'); return BTC_API_BASE+path; };

    // --- OP_RETURN parsing ---
    function readLE(hex, off, bytes){ let v=0; for(let i=0;i<bytes;i++) v|=parseInt(hex.substr(off+i*2,2),16)<<(8*i); return v; }
    function extractOpReturnFromHexScript(scriptHex){
      if(!scriptHex) return null;
      const h=scriptHex.toLowerCase().replace(/[^0-9a-f]/g,''); let i=0, out='';
      const readByte=()=>{ const b=parseInt(h.substr(i,2),16); i+=2; return b; };
      while(i<h.length){
        const op=readByte();
        if(op===0x6a){
          while(i<h.length){
            const b=parseInt(h.substr(i,2),16); if(Number.isNaN(b)) break;
            if(b>=1&&b<=75){ i+=2; const len=b; out+=h.substr(i,len*2); i+=len*2; continue; }
            if(b===0x4c){ i+=2; const len1=parseInt(h.substr(i,2),16); i+=2; out+=h.substr(i,len1*2); i+=len1*2; continue; }
            if(b===0x4d){ i+=2; const len2=readLE(h,i,2); i+=4; out+=h.substr(i,len2*2); i+=len2*2; continue; }
            if(b===0x4e){ i+=2; const len4=readLE(h,i,4); i+=8; out+=h.substr(i,len4*2); i+=len4*2; continue; }
            break;
          }
          return out||null;
        }
      }
      return null;
    }
    function extractOpReturnHex(voutAsm, voutHex){
      if(voutAsm && voutAsm.indexOf('OP_RETURN')===0){
        const parts=voutAsm.trim().split(/\s+/);
        const hexParts=parts.slice(1).filter(p=>/^[0-9a-fA-F]+$/.test(p));
        if(hexParts.length) return hexParts.join('').toLowerCase();
      }
      if(voutHex) return extractOpReturnFromHexScript(voutHex);
      return null;
    }
    function extractFirstMatchingFromTx(tx, pattern){
      if(!tx || !Array.isArray(tx.vout)) return null;
      for(const v of tx.vout){
        if(v && (v.scriptpubkey_type==='op_return' || (v.scriptpubkey_asm && v.scriptpubkey_asm.indexOf('OP_RETURN')===0))){
          const dataHex=extractOpReturnHex(v.scriptpubkey_asm, v.scriptpubkey);
          if(dataHex && hexIncludes(dataHex, pattern)) return { where:'OP_RETURN', dataHex };
        }
      }
      return null;
    }

    // --- Pattern ---
    function buildHexPattern(){
      const asciiOn=!!elUseAscii.checked, wildcardOn=!!elUseWildcard.checked;
      if(asciiOn){
        const src=elAsciiInput.value||''; let hex='';
        for(let i=0;i<src.length;i++) hex+= (wildcardOn && src[i]==='?') ? '??' : src.charCodeAt(i).toString(16).padStart(2,'0');
        return { re:new RegExp(hex.replace(/\?\?/g,'[0-9a-f]{2}')), isRegex:wildcardOn, hex:hex.toLowerCase() };
      }else{
        const raw=(elHexInput.value||'').replace(/\s+/g,'').toLowerCase();
        return wildcardOn ? { re:new RegExp(raw.replace(/\?\?/g,'[0-9a-f]{2}')), isRegex:true, hex:raw } : { re:null, isRegex:false, hex:raw };
      }
    }
    const hexIncludes=(t,pat)=>{ const s=String(t||'').toLowerCase(); if(!s) return false; return pat.isRegex ? pat.re.test(s) : s.indexOf(pat.hex)!==-1; };

    // --- Pools metadata & detection ---
    let POOLS=null;
    async function loadPools(){
      try{
        const json = await fetchJSON(bust(POOLS_JSON_URL), { cache: 'no-store', timeout: 15000 });
        const coinbaseTags = []; const payoutAddresses = new Map(); const slugsByName = new Map();

        if (json.coinbase_tags){
          for (const [pattern, v] of Object.entries(json.coinbase_tags)){
            coinbaseTags.push({ pattern, name: v.name, link: v.link });
          }
        }
        if (json.payout_addresses){
          for (const [addr, v] of Object.entries(json.payout_addresses)){
            payoutAddresses.set(addr, { name: v.name, link: v.link });
          }
        }
        if (json.slugs){
          for (const [name, slug] of Object.entries(json.slugs)){
            slugsByName.set(name, slug);
          }
        }
        // Also hydrate payoutAddresses from v2 "pools" entries that list known addresses
        if (Array.isArray(json.pools)){
          for (const p of json.pools){
            if (!p || !p.name) continue;
            const slug = slugsByName.get(p.name);
            if (Array.isArray(p.addresses)){
              for (const addr of p.addresses){
                if (!payoutAddresses.has(addr)){
                  payoutAddresses.set(addr, { name: p.name, link: p.link, slug });
                }
              }
            }
          }
        }

        // attach slugs
        for (const e of coinbaseTags){ e.slug = slugsByName.get(e.name); }
        payoutAddresses.forEach((meta, addr) => {
          if (!meta.slug && meta.name){
            const s = slugsByName.get(meta.name);
            payoutAddresses.set(addr, { ...meta, slug: s });
          }
        });

        POOLS = { coinbaseTags, payoutAddresses, slugsByName };
      }catch(e){
        POOLS = { coinbaseTags: [], payoutAddresses: new Map(), slugsByName: new Map() };
      }
    }

    // Fallback regexes (adds SECPOOL, SpiderPool, Binance Pool, Mining Squared + common pools)
    const FALLBACK_TAGS = [
      { re: /(secpool|sec *pool)/i,                   name: "SECPOOL",        slug: "secpool",       link: "https://www.secpool.com" },
      { re: /(spider ?pool|spiderpool)/i,             name: "SpiderPool",     slug: "spiderpool",    link: "https://www.spiderpool.com" },
      { re: /(binance( *pool)?|bnbpool)/i,            name: "Binance Pool",   slug: "binancepool",   link: "https://pool.binance.com" },
      { re: /(mining *squared|miningsquared|bsquared)/i, name: "Mining Squared", slug: "miningsquared", link: "https://miningsquared.com" },

      { re: /(foundry|foundryusa)/i,                  name: "Foundry USA",    slug: "foundryusa",    link: "https://foundrydigital.com" },
      { re: /(antpool)/i,                             name: "AntPool",        slug: "antpool",       link: "https://www.antpool.com" },
      { re: /(f2pool)/i,                              name: "F2Pool",         slug: "f2pool",        link: "https://www.f2pool.com" },
      { re: /(viabtc)/i,                              name: "ViaBTC",         slug: "viabtc",        link: "https://www.viabtc.com" },
      { re: /(btc[.]com|btccom)/i,                    name: "BTC.com",        slug: "btccom",        link: "https://pool.btc.com" },
      { re: /(luxor)/i,                               name: "Luxor",          slug: "luxor",         link: "https://mining.luxor.tech" },
      { re: /(sbi.*crypto)/i,                         name: "SBI Crypto",     slug: "sbicrypto",     link: "https://www.sbicrypto.com" },
      { re: /(mara|marapool)/i,                       name: "MARA Pool",      slug: "marapool",      link: "https://www.mara.xyz" }
    ];

    function matchFallbackTag(ascii){
      for(const t of FALLBACK_TAGS){ if(t.re.test(ascii)) return { name:t.name, slug:t.slug, link:t.link }; }
      return undefined;
    }

    function detectPoolFromTags(ascii){
      if(POOLS){
        for(const entry of POOLS.coinbaseTags){
          try{ const re=new RegExp(entry.pattern,'i'); if(re.test(ascii)) return {name:entry.name,link:entry.link,slug:entry.slug}; }
          catch(e){ if(ascii.toLowerCase().includes(String(entry.pattern).toLowerCase())) return {name:entry.name,link:entry.link,slug:entry.slug}; }
        }
      }
      return matchFallbackTag(ascii);
    }

    function detectPoolFromPayouts(coinbaseTx){
      if(!POOLS || !coinbaseTx || !Array.isArray(coinbaseTx.vout)) return undefined;
      for(const o of coinbaseTx.vout){
        const addr=o && o.scriptpubkey_address;
        if(addr && POOLS.payoutAddresses.has(addr)) return POOLS.payoutAddresses.get(addr);
      }
      return undefined;
    }

    async function getBlockExtras(blockHash){
      try{ const b=await fetchJSON(bust(api("/block/"+blockHash))); if(b && b.extras && b.extras.pool) return {name:b.extras.pool.name, link:b.extras.pool.link, slug:b.extras.pool.slug}; }catch(e){}
      try{ const b2=await fetchJSON(bust(MEMPOOL_API+"/block/"+blockHash)); if(b2 && b2.extras && b2.extras.pool) return {name:b2.extras.pool.name, link:b2.extras.pool.link, slug:b2.extras.pool.slug}; }catch(e){}
      return null;
    }

    function detectPool(coinbaseTx, extras){
      if(extras && (extras.name || extras.slug)){
        if (!extras.slug && POOLS && POOLS.slugsByName && extras.name) {
          const s = POOLS.slugsByName.get(extras.name);
          if (s) extras.slug = s;
        }
        return extras;
      }
      const ssHex=(coinbaseTx && coinbaseTx.vin && coinbaseTx.vin[0] && coinbaseTx.vin[0].scriptsig)||'';
      const ascii=hexToAscii(ssHex||'');
      const byTag=detectPoolFromTags(ascii); if(byTag) return byTag;
      const byAddr=detectPoolFromPayouts(coinbaseTx); if(byAddr) return byAddr;
      return undefined;
    }

    // --- Esplora helpers ---
    const fetchBlocksPage = ()=>fetchJSON(bust(api("/blocks")));
    const fetchBlocksPageFrom = (h)=>fetchJSON(bust(api("/blocks/"+h)));
    const fetchTipBlocks = ()=>fetchJSON(bust(api("/blocks")));
    async function getCoinbaseTx(blockHash){
      const page=await fetchJSON(bust(api("/block/"+blockHash+"/txs/0")));
      return (page && page[0]) || null;
    }

    // --- Rendering ---
    const poolLogoUrl=(slug)=> slug ? (POOL_LOGO_BASE+"/"+slug+".svg") : (POOL_LOGO_BASE+"/default.svg");

    const poolCounts=new Map();
    function incrPoolCount(pool){
      const key=(pool && (pool.slug || pool.name)) || 'Unknown';
      const prev=poolCounts.get(key) || { count:0, name:(pool && pool.name)||'Unknown', slug:pool && pool.slug, link:pool && pool.link };
      prev.count+=1; poolCounts.set(key,prev); renderPoolsSummary();
    }
    function renderPoolsSummary(){
      const arr=[...poolCounts.values()].sort((a,b)=>b.count-a.count);
      elPoolsBox.innerHTML = arr.length
        ? arr.map(p=>`<div class="poolCard">
            <div class="logo"><img alt="${p.name||'Pool'}" src="${poolLogoUrl(p.slug)}" onerror="this.src='${POOL_LOGO_BASE}/default.svg'" crossOrigin="anonymous"/></div>
            <div style="min-width:0"><div style="font-weight:600">${p.name||'Unknown'}</div>
            <div class="muted" style="font-size:12px">Matches: ${p.count}</div></div>
            <div style="margin-left:auto;font-size:12px">${p.link?`<a href="${p.link}" target="_blank">website</a>`:''}</div>
          </div>`).join('')
        : '<div class="muted">No pools detected yet — results will appear here as matches come in.</div>';
    }

    function renderItemCard(row){
      const b=row.block, pool=row.pool||{name:'Unknown'}, when=new Date(b.timestamp*1000);
      const logo=poolLogoUrl(pool.slug), where=row.matchedWhere||'OP_RETURN';
      const opAscii=row.matchedDataHex ? hexToAscii(row.matchedDataHex) : '';
      const div=document.createElement('div'); div.className='item';
      div.innerHTML=`
        <div class="logo"><img alt="${pool.name||'Pool'}" src="${logo}" onerror="this.src='${POOL_LOGO_BASE}/default.svg'" crossOrigin="anonymous"/></div>
        <div style="flex:1;min-width:0">
          <div class="row wrap" style="gap:8px">
            <span class="pill mono">MATCH · ${where}</span>
            <a class="mono" href="https://mempool.space/block/${b.id}" target="_blank">${b.height} · ${shortHash(b.id)}</a>
            <span class="muted">${when.toLocaleString()}</span>
          </div>
          <div class="muted" style="margin-top:4px;font-size:14px">Pool:
            <span style="color:#e5e7eb">${pool.name||'Unknown'}</span>
            ${pool.link?`· <a href="${pool.link}" target="_blank">website</a>`:''}
          </div>
          ${row.matchedDataHex?`
            <div class="mono" style="margin-top:6px;font-size:12px;word-break:break-all">
              <div class="muted">Matched bytes (hex):</div>
              <div>${row.matchedDataHex}</div>
              <div class="muted" style="margin-top:4px">As ASCII (non‑printables as .):</div>
              <div>${opAscii}</div>
            </div>`:''}
        </div>
        <div style="text-align:right;font-size:12px">
          <div class="muted">Matched tx</div>
          <a class="mono" href="https://mempool.space/tx/${row.matchedTxid}" target="_blank">${shortHash(row.matchedTxid)}</a>
          ${(row.coinbaseTxid && row.coinbaseTxid!==row.matchedTxid)?(`<div class="muted" style="margin-top:6px">Coinbase tx</div><a class="mono" href="https://mempool.space/tx/${row.coinbaseTxid}" target="_blank">${shortHash(row.coinbaseTxid)}</a>`):''}
        </div>`;
      return div;
    }
    function renderItemAppend(row){
      const node=renderItemCard(row); elList.appendChild(node);
      while(elList.childElementCount>50) elList.removeChild(elList.firstChild);
      incrPoolCount(row.pool);
    }
    function renderItemPrepend(row){
      const node=renderItemCard(row);
      if(elList.firstChild) elList.insertBefore(node, elList.firstChild); else elList.appendChild(node);
      while(elList.childElementCount>50) elList.removeChild(elList.lastChild);
      incrPoolCount(row.pool);
    }

    // --- Core logic ---
    let blocksChecked=0, txChecked=0, matchesCount=0, processedBlocks=new Set();
    const setError=(m)=>{ elError.style.display=m?'block':'none'; elError.textContent=m||''; };
    const renderCounters=()=>{ elBlocksChecked.textContent=String(blocksChecked); elTxChecked.textContent=String(txChecked); elMatches.textContent=String(matchesCount); elLastUpdate.textContent=nowStr(); };

    async function extractMatchFromBlock(block, pattern){
      let extras=null, coinbase=null;
      try{ extras=await getBlockExtras(block.id); }catch(e){}
      try{ coinbase=await getCoinbaseTx(block.id); }catch(e){}
      blocksChecked++;

      if(coinbase){
        const cbMatch=extractFirstMatchingFromTx(coinbase, pattern);
        if(cbMatch) return { matchedTxid:coinbase.txid, matchedWhere:cbMatch.where, matchedDataHex:cbMatch.dataHex, coinbaseTxid:coinbase.txid, pool:detectPool(coinbase, extras) };
        const ssHex=(coinbase && coinbase.vin && coinbase.vin[0] && coinbase.vin[0].scriptsig)||'';
        if(ssHex && hexIncludes(ssHex, pattern)){
          return { matchedTxid:coinbase.txid, matchedWhere:'scriptSig', matchedDataHex:ssHex, coinbaseTxid:coinbase.txid, pool:detectPool(coinbase, extras) };
        }
      }
      let page=0;
      while(true){
        let txs=null; try{ txs=await fetchJSON(bust(api("/block/"+block.id+"/txs/"+page))); }catch(e){ break; }
        if(!txs || !txs.length) break;
        txChecked+=txs.length;
        for(const tx of txs){
          const match=extractFirstMatchingFromTx(tx, pattern);
          if(match) return { matchedTxid:tx.txid, matchedWhere:match.where, matchedDataHex:match.dataHex, coinbaseTxid:(coinbase&&coinbase.txid)||null, pool:detectPool(coinbase, extras) };
        }
        page++; if(page>80) break; await sleep(10);
      }
      return null;
    }

    // Initial fill (append so newest stays at top)
    async function initialFill(target){
      const pat=buildHexPattern(); let found=0;
      let page=await fetchBlocksPage(); if(!page || !page.length) return;
      let nextHeight=page[page.length-1].height - 1;

      while(found<target){
        for(const b of page){
          if(processedBlocks.has(b.id)) continue;
          processedBlocks.add(b.id);
          try{
            const res=await extractMatchFromBlock(b, pat);
            if(res){ matchesCount++; found++; renderItemAppend({ block:b, ...res }); }
          }catch(e){}
          renderCounters();
          if(found>=target) break;
          await sleep(15);
        }
        if(found>=target) break;
        try{ page=await fetchBlocksPageFrom(nextHeight); nextHeight = page.length ? page[page.length-1].height - 1 : nextHeight - 10; }catch(e){ break; }
        if(!page.length) break;
      }
    }

    // Poll tip (backup to WS)
    async function pollNew(){
      const pat=buildHexPattern();
      try{
        const latest=await fetchTipBlocks();
        for(let i=latest.length-1;i>=0;i--){
          const b=latest[i];
          if(processedBlocks.has(b.id)) continue;
          processedBlocks.add(b.id);
          try{
            const res=await extractMatchFromBlock(b, pat);
            if(res){ matchesCount++; renderItemPrepend({ block:b, ...res }); }
          }catch(e){}
          renderCounters();
          await sleep(25);
        }
      }catch(e){ setError('Polling error: '+e.message); }
    }

    // --- WebSocket for live blocks ---
    function startBlocksWs(){
      try{
        const ws = new WebSocket(WS_URL);
        let pingTimer = null;
        ws.addEventListener('open', () => {
          try{ ws.send(JSON.stringify({ action:'want', data:['blocks'] })); }catch(e){}
          // keepalive ping every 25s (some CDNs drop idle WS)
          pingTimer = setInterval(() => { try{ ws.send('ping'); }catch(e){} }, 25000);
        });
        ws.addEventListener('message', async (ev) => {
          try{
            const msg = JSON.parse(ev.data||'{}');
            const blockObj = msg.block || msg;
            const hash = blockObj.hash || blockObj.id || blockObj.block_hash || blockObj.blockHash;
            if (!hash) return;
            if (processedBlocks.has(hash)) return;
            const b = await fetchJSON(bust(api('/block/'+hash)));
            if (!b || !b.id) return;
            if (processedBlocks.has(b.id)) return;
            processedBlocks.add(b.id);
            const pat = buildHexPattern();
            const res = await extractMatchFromBlock(b, pat);
            if (res){ matchesCount++; renderItemPrepend({ block:b, ...res }); renderCounters(); }
          }catch(e){}
        });
        ws.addEventListener('close', () => { if (pingTimer) clearInterval(pingTimer); setTimeout(startBlocksWs, 3000); });
        ws.addEventListener('error', () => { try{ ws.close(); }catch(e){} });
        return () => { try{ if (pingTimer) clearInterval(pingTimer); ws.close(); }catch(e){} };
      }catch(e){ /* ignore */ }
      return ()=>{};
    }

    // --- Tests ---
    function addTestResult(ok, msg){ elTestsBox.style.display='block'; const li=document.createElement('li'); li.className=ok?'ok':'fail'; li.textContent=(ok?'✓ ':'✗ ')+msg; elTests.appendChild(li); }
    async function runTests(){
      try{
        const ex1=extractOpReturnHex('OP_RETURN 73616d706c65'); addTestResult(ex1==='73616d706c65','extract OP_RETURN single push');
        const ex2=extractOpReturnHex('OP_RETURN 7361 6d70 6c65'); addTestResult(ex2==='73616d706c65','extract OP_RETURN multi push join');
        const ex4=extractOpReturnFromHexScript('6a4c0b68656c6c6f20776f726c64'); addTestResult(ex4==='68656c6c6f20776f726c64','extract PUSHDATA1');
        const ex5=extractOpReturnFromHexScript('6a4d0300112233'); addTestResult(ex5==='112233','extract PUSHDATA2 len=3');
        const ex6=extractOpReturnFromHexScript('6a4e03000000aabbcc'); addTestResult(ex6==='aabbcc','extract PUSHDATA4 len=3');
        const ex7=extractOpReturnFromHexScript('6a01610162'); addTestResult(ex7==='6162','extract multi-push concat');
        elUseAscii.checked=true; elUseWildcard.checked=false; elAsciiInput.value='sys';
        const pA=buildHexPattern(); addTestResult(pA.hex==='737973','ASCII sys → hex'); addTestResult(hexIncludes('00737973ff',pA)===true,'includes sys');

        // NEW: fallback tag tests (no network required)
        const t1 = detectPoolFromTags('Mined by SpiderPool'); addTestResult(!!t1 && t1.name==='SpiderPool','fallback: SpiderPool');
        const t2 = detectPoolFromTags('Welcome to SEC Pool'); addTestResult(!!t2 && /SECPOOL/i.test(t2.name),'fallback: SECPOOL');
        const t3 = detectPoolFromTags('binance pool best'); addTestResult(!!t3 && /Binance Pool/i.test(t3.name),'fallback: Binance Pool');
      }catch(e){ addTestResult(false,'Tests threw: '+e); }
    }

    // --- Boot ---
    (async function init(){
      elAsciiInput.value=DEFAULT_ASCII; elAsciiAsHex.textContent=asciiToHex(DEFAULT_ASCII);

      try{ await pickEsploraBase(); }catch(e){ setError('Could not reach any Bitcoin API endpoint. The app will idle until network is available.'); return; }
      try{ const t=await fetchTEXT(bust(SYSCOIN_HASHRATE_URL),{ cache:'no-store', timeout:8000 }); const n=Number((t||'').trim()); elHashrate.textContent=Number.isFinite(n)?formatHps(n):'–'; }catch(e){}
      try{ await loadPools(); }catch(e){ setError('Pool metadata failed to load — logos/names may be missing.'); }
      await runTests();

      // Fill and then keep live
      try{ await initialFill(50); }catch(e){ setError('Initial scan failed: '+e.message); }
      renderCounters();

      // WS live updates + backup poll
      const stopWs = startBlocksWs(); // live blocks via WebSocket
      setInterval(pollNew, 30000);
      // tip-hash watcher: force-refresh when a new block arrives (works even if WS is blocked)
      let lastTipHash = null;
      async function checkTip(){
        try{
          const tip = await fetchTEXT(bust(api('/blocks/tip/hash')));
          const h = (tip||'').trim();
          if (h && h !== lastTipHash){
            lastTipHash = h;
            if (!processedBlocks.has(h)){
              try{
                const b = await fetchJSON(bust(api('/block/'+h)));
                if (b && b.id){
                  processedBlocks.add(b.id);
                  const pat = buildHexPattern();
                  const res = await extractMatchFromBlock(b, pat);
                  if (res){ matchesCount++; renderItemPrepend({ block:b, ...res }); renderCounters(); }
                }
              }catch(e){}
            }
          }
        }catch(e){ /* ignore */ }
      }
      setInterval(checkTip, 12000);

      // UI wiring
      elAsciiInput.addEventListener('input', ()=>{ elAsciiAsHex.textContent=asciiToHex(elAsciiInput.value||''); });
      elUseAscii.addEventListener('change', ()=>{ elAsciiBox.style.display = elUseAscii.checked ? 'block' : 'none'; });

      renderPoolsSummary();
    })();
  </script>
</body>
</html>
